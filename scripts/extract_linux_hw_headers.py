import os
import re
import xml.etree.ElementTree as ET
from datetime import datetime

# Paths (Relative to script execution in project root)
QSYS_FILE = "soc_system.qsys"
SYSTEM_H_FILE = "software/npu_bsp/system.h"
OUTPUT_H_FILE = "linux_software/npu_test/hw_addresses.h"

def parse_qsys(filepath):
    """
    Parses the Qsys XML file to extract base addresses of specific components.
    Currently extracts MSGDMA (CSR/Descriptor) and NPU_CTRL base addresses.
    """
    offsets = {}
    if not os.path.exists(filepath):
        print(f"Warning: {filepath} not found.")
        return offsets
        
    try:
        tree = ET.parse(filepath)
        root = tree.getroot()
        
        # Look in the bonusData section which contains baseAddress dumps easily
        for param in root.findall(".//parameter[@name='bonusData']"):
            bonus_data = param.text
            if not bonus_data: continue
            
            # Simple Regex parsing of the bonusData string format
            # Example:
            # element ddr_read_st.csr
            # {
            #    datum baseAddress { value = "200704"; type = "String"; }
            # }
            
            elements = re.split(r'element\s+', bonus_data)
            for el in elements:
                name_match = re.match(r'([A-Za-z0-9_\.]+)', el)
                addr_match = re.search(r'datum\s+baseAddress\s*\{[^}]*value\s*=\s*"(\d+)"', el)
                
                if name_match and addr_match:
                    name = name_match.group(1)
                    addr = int(addr_match.group(1))
                    
                    if name == "npu_ctrl.s0":
                        offsets["NPU_CTRL_OFFSET"] = addr
                    elif name == "ddr_read_st.csr":
                        offsets["DDR_READ_ST_CSR_OFFSET"] = addr
                    elif name == "ddr_read_st.descriptor_slave":
                        offsets["DDR_READ_ST_DESC_OFFSET"] = addr
                    elif name == "ddr_write_st.csr":
                        offsets["DDR_WRITE_ST_CSR_OFFSET"] = addr
                    elif name == "ddr_write_st.descriptor_slave":
                        offsets["DDR_WRITE_ST_DESC_OFFSET"] = addr
    except Exception as e:
        print(f"Error parsing Qsys: {e}")
        
    return offsets

def parse_system_h(filepath):
    """
    Optional: Parses system.h generated by BSP to extract macros.
    This acts as a fallback or cross-reference.
    """
    offsets = {}
    if not os.path.exists(filepath):
        return offsets

    try:
        with open(filepath, 'r') as f:
            content = f.read()
            
            # Find macros like #define NPU_CTRL_BASE 0x30000
            for line in content.split('\n'):
                match = re.search(r'#define\s+([A-Z0-9_]+_BASE)\s+(0x[0-9a-fA-F]+|\d+)', line)
                if match:
                    macro_name = match.group(1).replace("_BASE", "_OFFSET")
                    val_str = match.group(2)
                    offsets[macro_name] = int(val_str, 0)
    except Exception as e:
        print(f"Error parsing system.h: {e}")
        
    return offsets

def generate_header(qsys_offsets, sys_offsets, output_path):
    # Prefer Qsys offsets, merge with system.h if available
    merged_offsets = {**sys_offsets, **qsys_offsets}
    
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    with open(output_path, 'w') as f:
        f.write("/*\n")
        f.write(" * Auto-generated Linux Hardware Address Header\n")
        f.write(f" * Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(" * This file maps Qsys/BSP components to Linux userspace /dev/mem offsets.\n")
        f.write(" */\n\n")
        
        f.write("#ifndef _HW_ADDRESSES_H_\n")
        f.write("#define _HW_ADDRESSES_H_\n\n")
        
        f.write("// ==========================================\n")
        f.write("// Bridge Offsets (Fixed Architecture)\n")
        f.write("// ==========================================\n")
        f.write("#define LWHPS2FPGA_BASE 0xFF200000\n")
        f.write("#define LWHPS2FPGA_SPAN 0x00200000\n\n")
        f.write("#define HPS_FPGA_RAM_BASE 0xC0000000\n")
        f.write("#define HPS_FPGA_RAM_SPAN 0x01000000 // 16MB Window\n\n")
        
        f.write("// ==========================================\n")
        f.write("// Component Offsets (Extracted from Qsys)\n")
        f.write("// ==========================================\n")
        
        # Sort and write
        for key in sorted(merged_offsets.keys()):
            if "NPU" in key or "DDR" in key: # Filter to relevant IPs
                f.write(f"#define {key:<30} 0x{merged_offsets[key]:08X}\n")
                
        f.write("\n#endif /* _HW_ADDRESSES_H_ */\n")
        
    print(f"Successfully generated {output_path}")

if __name__ == "__main__":
    print("Extracting hardware addresses...")
    qsys_offsets = parse_qsys(QSYS_FILE)
    sys_offsets = parse_system_h(SYSTEM_H_FILE)
    
    generate_header(qsys_offsets, sys_offsets, OUTPUT_H_FILE)
